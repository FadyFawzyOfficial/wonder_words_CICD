#* 1. Defines the name for this specific workflow.
name: Test, build and deploy

#! 2. Specifies the events on which to execute this workflow. In this case,
#! it will run when the pull request is merged to the develop branch as well as
#! when new code is pushed to the develop branch.
on:
  pull_request:
    branches:
      - develop
  push:
    branches:
      - develop

#* 3. Defines the permission scope.
permissions: read-all

#? 4. Lists the jobs that will run in this workflow.
jobs:
  # Completed: Remove the example job after testing
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      #* 1. Clones the Flutter, which is necessary to execute the tests.
      - name: Clone flutter repository with master channel
        uses: subosito/flutter-action@v2
        with:
          channel: master

      #* 2. Runs Flutter doctor, which will install all the necessary development tools
      - name: Run flutter doctor
        run: flutter doctor -v
      

      #* 3. Checks out the code.
      - name: Checkout code
        uses: actions/checkout@v2

      #* 4. Fetches the missing packages and runs make test, which will run tests in all packages
      - name: Get all packages and test
        run: make get && make testing

  # Completed: add a job for building Android app
  android:
    name: Build Android
    runs-on: ubuntu-latest
    steps:
      #! 1. Clone Flutter, run Flutter doctor and check out the code.
      - name: Clone flutter repository with master channel
        uses: subosito/flutter-action@v2
        with:
          channel: master
      - name: Run flutter doctor
        run: flutter doctor -v
      - name: Checkout code
        uses: actions/checkout@v2
      #! 2. Install Java JDK, which is required to build your app.
      - name: Set up JDK 1.8
        uses: actions/setup-java@v1
        with:
          java-version: 1.8
      #! 3. Clean the repository and fetch packages.
      #* Additionally, you could add `make lint` and `make format` commands here.
      #* They would throw an error and cancel the build in cases where the app
      #* doesn't obey the rules of linting or is in correctly formatted.
      #? But the better option would be to use Git hooks with Flutter Lefthook,
      #? which would run those 2 commands before committing.
      #! In the case of any issues, it wouldn't let the developer push the changes to the remote.
      #! This is a good practice, as it resolves formatting and linting issues before the build.
      - name: Clean and fetch packages
        run: make clean && make get
      #* 4. Finally, builds the Android APK.
      - name: Build apk
        run: flutter build apk
      
      # ToDo: add deployment logic

  
  
  
  
  
  
  
  
  # #! 5. Defines the unique identifier for the job, Jobs from a single workflow run in
  # #! parallel unless you define that one job is a prerequisite for another one.
  # #! This is where those unique identifiers come in handy.
  # example:
  #   name: Example of a job
  #   #* 6. Specifies the OS for the machine on which the job will run.
  #   runs-on: ubuntu-latest
  #   #* 7. Lists the steps that will run in a predefined order.
  #   steps:
  #     #* 8. Define the name of the step and command that will be executed
  #     - name: Echo text
  #       run: echo This\ is\ my\ first\ Github\ actions\ job